Design Decisions
================

---------------------------
Object Binding Architecture
---------------------------

.. NOTE::
    This is not meant to criticize other frameworks for their
    choices- I respect them and I am just giving my reasons why
    express doesn't use them.

With express being used for most of my tiny projects, I've
often needed to bind multiple middleware together, and then
let them access the "current" app (same as ``flask.current_app``,
but much more lower-level).

There are several ways in which this can be achieved, using
other methods rather than having object binding:

- Store the current app in a global variable, like what Flask
  does in their ``current_app`` object, making it readily
  accessible by other middleware that may want to use it.
- Make everything implicit like Bottle, where you can only
  have one instance of the app (though there are workarounds).
- No global app, just an application object and let the user
  handle all of the global issues by himself, something which
  most people would rather not do.

But no, I do not like the idea of any of them- Flask's ``current_app``
object seems kinda nice- though I do need to dig deep into their code
to see how that's done. But that's handled by Flask already. So I
decided to make my own inheritance system (if you will) and came up
with express's binding architecture.

Basically, the express instance (upon creation via the __init__
method), will create the configuration variables, and set up itself
by binding other middleware.

The other middleware which are binded (using their ``setup`` method)
to the express instance will then set the required attributes, dictated
by their own ``functions`` property or another list, on the express
instance. This is one of the object binding methods.

The second method involves a much more simple binding- where the
functions of the middleware (which receives an express instance as it's
first argument) are binded into a new object within the express instance
named after the middleware.

-----------------
Module as a class
-----------------

You might have noticed that the express module is in fact a class,
i.e. you might have done this::

    >>> import express
    >>> express
    <class 'express.express.Express'>

This behavior is entirely intended and specially crafted because I
thought it would be cool (which makes this decision entirely aesthetics
based). This is also because I would like to provide a convenience
function for the user by not requiring him to type ``express.express.Express()``
or ``express.express()``. Ain't nobody got time for that!

You might have asked why I didn't make the express module an instance
since that's what <*insert someone's name*> might have done, and that
would be "better". It's because I want to allow the developer to create
multiple express instances, each with their own middleware.

---------------------------------
Using Flask & Werkzeug as Routers
---------------------------------

.. NOTE::
    I am not trying to give you the impression that Flask and
    Werkzeug are not important in the express framework. They
    are in fact part of the backbone behind the framework.

Well, you cannot just make a new web framework just to make a web
API toolkit, so why do so? Well-established frameworks which are
Flask and Werkzeug have already been designed by cool people with
crazy skills.

Flask is lightweight, and Werkzeug is a nice WSGI router which
so much important features that I cannot possibly concatenate them
into one sentence. Here's a rather small list of features that it offers:

* Request & Response objects (practically every WSGI toolkit offers
  this but Werkzeug does it best in my opinion).
* URL Routing - every web framework requires one. Werkzeug makes it
  simple and aesthetically-cool at the same time.
* Views & Endpoints - can't stress on how much this has made my code
  more modular, but it has driven me crazy (sometimes).
* ``contrib`` - That massive library there is full of goodies. Every web
  app needs to use at least one of them.

The Flask web framework also ships with the Jinja templates engine
which is massive considering that it's a template engine. Seems to
resemble a web server or some kind of sandbox environment at times.

I also liked the Flask framework *very* much, and I have been using
it in my web apps. If you happen to dislike it, you can always edit the
code internally and subclass the express instance to suit you needs.

Plus, you need a web server to test out your API, and somewhere
to mount your API on. Or else you've just wasted hours of your life
making your perfect API without being able to push it online.

------------------------------------
Difference between helpers & contrib
------------------------------------

You might have noticed that there are two different libraries of
helper functions within express- the contrib and helpers library.
Some of the functions are found here, some are found there.

But the primary difference between them is that helpers is primarily
for classes and bindings which are made for the express instance to
bind to.

The contrib library, on the other hand, is a massive file in which I
dump all of the helpers I used in my previous web apps. The contrib
library will continue to grow massively over time, but the helpers
library will only be more stable and perhaps experience more internal
changes.

---------------------
Not too many features
---------------------

In a development environment, you might want a framework which does
nearly everything for you- databases, templates, etc. And you may also
want a framework which is crazy fast. But in production environments,
you do not need a really fast but fragile framework- nor do you need
frameworks which do everything for you and slow the server down.
