Introduction
============

---------------
Getting Started
---------------

In the following example we will create an express API
which can take in both get and post requests. The final
API will take in both method names and parameters.

First we will import our required modules, and set up
our local environment::

    import platform
    import express
    app = express()


---------------
Serve functions
---------------

Now that we have done that, it's time to create the
functions which will enable API access to the user.
Note that the functions must accept a ``request`` object
as their first argument.::

    @app.serve(methods=["GET"])
    def serve_get(request):
        return app.Model.resp(dict(status=None, value=request.remote_addr))

    # handle post requests only since it's the default.
    @app.serve()
    def serve_post(request):
        method = request.form["method"].strip()
        params = app.deserialize(request.form["params"])
        return app.Model._run(string=method, params=params)

The decorators are quite self explanatory- the first
decorated function will only cater to the ``GET`` requests,
while the second one will only cater to ``POST`` requests
since that is the default behaviour of the ``serve()`` 
decorator.

Note that in the ``serve_post`` function, we can see that the
parameters / flags of the API call is deserialized using JSON
(the default deserializer, more on that later) and passed to 
the ``Model._run`` function, which basically runs the command
and returns a dictionary to be serialized.

You do not need to serialize the return values of the serve
functions as express already does it for you.


--------
Commands
--------

Now we will create the commands in which the API will
respond to, or a list of commands, i.e. in a shell you may
type ``ls`` and you get a list of directories- the concept
is similar.

Commands are called ``events`` in express, and they can
be specified using the ``app.event`` decorator.::

    @app.event("hello")
    def hello_name(**param):
        return "Hello," + param["name"]

    @app.event("stats")
    def get_stats():
        return platform.platform()


-------------------
Starting the server
-------------------

And now we shall run the app with the ``Flask.debug`` flag
set to True (so the ``werkzeug`` server will reload upon
code changes). In this case, we are telling express that we
want to host on port 5000.::

    app.set("RUN-FLAGS",{"debug":True})
    app.listen(5000)

You should see something like this in your display::

     * Running on http://localhost:5000/
     * Restarting with reloader


----------------
Making API calls
----------------

**Note**: Depending on where you specify your ``API-MOUNTPOINT`` path
(which defaults to "/"), you may need to direct your API calls
to somewhere else rather than the index path.

To test out our API we can do something like that, with the ``requests``
library installed::

    >>> payload = {"method":"stats", "params":"{}"}
    >>> r = requests.post("http://localhost:5000/", data=payload)
    >>> r.text
    '{"status":"True","value":"Darwin-10.8.0-x86_64-i386-64bit"}'

Or if you want to test out your command that accepts parameters you can
do something like this::

    >>> payload = {"method":"hello", "params":'{"name":"Eugene"}'}
    >>> r = requests.post("http://localhost:5000/", data=payload)
    >>> r.text
    '{"status":"True","value":"Hello,Eugene"}'

You can test out your ``GET``-routed function like this:

    >>> requests.get("http://localhost:5000/").text
    '{"status":"None","value":"127.0.0.1"}'

Note that you will see the ``application/json`` as the ``Content-Type``
key of the HTTP header in the response. This is because the express
framework will set the ``Content-Type`` part of the header to the ``META-TYPE``
configuration variable.


-----------------------------
Touching the Advanced Section
-----------------------------

You may want to access and utilize more advanced configurations like
changing the API's "mountpoint" (where it can be accessed) or the
serializer (though you should *not* use ``pickle``). The following
configurations are available:

* ``META-TYPE`` - The string to be placed in the ``Content-Type``
  section of the header.
* ``API-MOUNTPOINT`` - The place to "mount" the API, i.e. "/" or "/api"
  if you want to have a specific access point.
* ``SERIALIZER`` - The default serializer to use- defaults to ``json``
  but you may want to use ``yaml``.

