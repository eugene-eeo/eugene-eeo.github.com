<html>
<head>
<style type="text/css">
* {
	font-family: monospace!important;
	font-size: 1em;
	outline: none;
	color: #222;
}
body {
	width: 650px;
	margin-left: auto;
	margin-right: auto;
	margin-top: 0.5em;
}
a {
	color: #3b5998;
	text-decoration: none;
}
h1 {
	font-size: 20pt;
	margin-bottom: 0px;
}
h2 {
	font-size: 16pt;
	margin-bottom: 8px;
}
h3 {
	font-size: 13pt;
	margin-bottom: 0px;
}
table {
	width: 100%;
}
span {width: 100%; display: inline;}
td {
	width: 100%;
	background-color: #EEE;
}
p {text-align: left;}
</style>
<title>Dynamic Stack Concept</title>
</head>
<body>
<table width="100%">
	<tr><td width="100%" style="background-color: #3b5998; height:5px"></td></tr>
	<tr><td width="100%">[<a href="index.html">Back to Index</a>] UUID: de9de7f0-a1b1-11e2-9e96-0800200c9a66</td></tr>
	<tr><td width="100%">Type: Concept [Informational]</td></tr>
</table>
<center>
<h3>XMLRPC NODE AS A STACK</h3>
USING NODE AS A DEVELOPMENT PLATFORM
<pre>






April 10, 2013


First Edition (No Revision)




Referral: eugene-eeo.github.com
Contact: packwolf58@gmail.com
</pre></center>


<center><b>ABOUT</b></center>
<p>
This document is meant not as a complete documentation for using XMLRPC Node (which will be referred to as Node in the rest of the document) but as a starting point to where you should head, and a guide for you, covering some of your needs while documenting others. You should not look here for a documentation of Node itself, but as a guide towards hosting applications with Node.
<p>
In order to fully utilize the contents onboard this document, I would assume that you have the CNI interface and the latest version of Node. I would also assume that you have properly configured worker nodes and a proper server setup- I will not go through the details of setting up your own Node system, but it is fairly straightforward, and you should refer to the <a href="node-plans.html">XMLRPC Node Concept</a> document.
<p>
A stack is defined as a "complete deployment environment including the base operating system, the language runtime and associated libraries" by [<a href="https://devcenter.heroku.com/articles/stack">Heroku</a>].


<center><b>MAIN APPLICATION</b></center>
<p>
	Ideally, your main application should be a high-availability Node, depending on your average traffic. And the main Node should not include the <code>server.finish</code> function when it finishes the task (or if you want and you are confident that your code wouldn't suddenly exit) so that it would run a script infinitely, and would only be killed when the server itself dies or the controller signals a halt.
<p>
	Scaling your Nodes is also an important part of web development, if not the second most important part. Scaling means balancing and distributing your workload throughout the entire server, which typically means something like the following:
	<pre>
    Unscaled Platform       Scaled Platform
    Worker1: [][][][]       Worker1: [][]
    Worker2: []             Worker2: [][]
    Worker3: []             Worker3: [][]
    Worker4: []             Worker4: [][]
  	</pre>
  	It provides an erosion free, dynamic and flexible platform to work with. For automatic scalling, there are little to consider- especially since there are generally only two types of Nodes- the high availability ones, which are the apps or lightweight commands, and the heavy duty, high reload-time ones, which typically provide the grunt behind everything. To manually scale something, you can just distribute the tasks equally and rationally; but for an automatically scaling application, you can code something like the following:
  	<pre>
Poll the server for any tasks that      Check for any empty Nodes, and
are loaded to the independent Nodes.    add them to a list.               
Worker1: [][][]                         Worker3: None                     
Worker2: []                                                               
Worker3: None                                                             

Place the tasks into the                Help out on that one extra task
empty node.                             by making the command node a 
Worker1: [][]                           hybrid.
Worker2: []                             Control: []
Worker3: []                             Worker1: []
  	</pre>
  	Though you have to keep in mind that Node is ideally, a simple first-in-first-out queue based system and not a monolithic or multitasking system- and you shouldn't implement it as a daemon-like system, either, as it reduces the complexity and just increases the meaning of having independent Nodes- scripts ran by the machine to get data from the server component.


<center><b>CORE NODES</b></center>
<p>
	Just to let you know, I used the name Core because everything sounds cooler with Core. Core Nodes are what I refer to as the workhorses of your platform, also refered to as worker dynos by Heroku. They are essentially the Nodes which run commands like the database management, scheduling, the indexing of files to your wiki, etc. Generally, the higher the availability, the better- but given that an application relies on both types of Nodes, the Main Application and the Core Nodes, you must again strike a balance between the various Nodes. You might have something like the following:
	<pre>
  Node                    Task                   Update Frequency
core-sqldb     python "update-sql.py" --all            1.0s
core-index     python "index.py" --all                 5.4s
core-svr       exec "server.py" 8000                   0.0s
main-app       python "status.py"                      1.0s
	</pre>
	Since your "status.py" application may show the data within the database that update-sql.py has created, and since the latter updates once every other second, it's wise to scale your nodes to the one like the above. For CGI scripts, this is more complex, but because your script is generally located in a static location and is normally unchaged, just running the core-svr node like the one above would do for most people.
<p>
	There is also a need for you to restructure your code (if you haven't done so already) so that some of them run forever, like the server scripts, and some of them don't, like the downloading or uploading ones. You should also, (best practice) start a new Node for a new "eternal" script, which is simply one looped via a while True function.
<p>
	Sometimes, you would spend lesser resources setting up another Node than to spend time coding and configuring that specific node, which is also another tip that I would like to provide to whoever who is using Node for their server or just for fun (I admit that I've been involved in the latter). I wonder if you could formulate an algorithm for figuring out the stress on a server: S = D/T, with D as the total size of the tasks and T as the number of nodes.
<p>
	You should also be aware that while Node is mainly a server and a task managing one, there is a need for the protection of binaries against reading by others, like setting it to execute only or read-by-none hex value using the chmod command- more on Unix file permissions <a href="http://www.dartmouth.edu/~rc/help/faq/permissions.html">here</a>.


<center><b>CUSTOMIZATION AND FURTHER NOTES</b></center>
<p>
	<b>4.1 LOGGING</b>
	<p>
		For Heroku-like logging, you can (although this is not natively supported in Node) use a slight modification of the default worker/slave node script- rather than appending the stuff in stdout to stdout, you can actually redirect it to another file, i.e. logs.txt. And then base your decisions off the content gained in that file. See below for this mod:
		<dd>9: subprocess.Popen(item, shell=True, stdout=open('logs.txt','w'), stderr=stdout)</dd>
<p>
	<b>4.2 CONCURRENCY</b>
	<p>
		Concurrency is defined as "a property of systems in which several computations are executing simultaneously, and potentially interacting with each other" [<a href="http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29">Wikipedia</a>]. And Nodes are supplied to aid in concurrency- though there are some limitations, for example adding more Nodes to help parse your database, which happens to be cluttered or bottlenecked- adding more Nodes might not solve the problem, but make it worse as more processes need to be executed.
	<p>
		Before launching anything on a stack-like task system like Node, you should probably streamline that piece of code and make sure it's "Node friendly", which means that it spawns as little processes as possible while keeping everything under control. Note that your Nodes can only spread out a task if it can be subdivided into smaller chunks, which is the entire point of Node- to divide, simplify, and to conquer. Node-friendly applications/binaries should be able to operate independently or off a database.
<p>
	<b>4.3 PERMISSIONS</b>
	<p>
		You should always make sure that the worker script or user has access to that particular file which you are requesting the node onboard their machine or account to execute. Refer to <a href="http://www.dartmouth.edu/~rc/help/faq/permissions.html">http://www.dartmouth.edu/~rc/help/faq/permissions.html</a> for a crash course into using the chmod Unix command. Note: Node is not tested with Windows, and will execute with the assumption that the command provided is always valid.
	<p>
		Permissions to edit some Nodes, on the other hand, is not natively supported as this is not really a "realistic" or "core" feature- the default Node workflow would always be similar to that of a dictator-like flow, where there is only one controller and Nodes obeying that controller.
<p>
	<b>4.4 CUSTOMIZATON</b>
	<p>
		Node was built with customization in mind, and that's why every function in the main Node (can't say the same for the CNI interface) is commented upon and documented via in-script comments. This makes it easy for you to programmably scale your applications and Nodes, and this would be a feature that I will introduce, if possible, into the next release (if everything goes well).
	<p>
		There is currently no native way to scale an application- you can override it by telling the server you've finished that task, and placing it into another task. I will add this native functionality too, in the next release.
<p>
	<b>4.5 DESIRED ENVIRONMENT</b>
	<p>
		Ideally, Node should be ran atop a Unix-based OS like OSX, Ubuntu, or other Linux distros, because of their simple filesystem, which avoids "injuries" during the reference of file paths, as there is no need for a drive character before the file path, i.e. C:\\Users\foo\bar.
<p>
	<b>4.6 SECURITY</b>
	<p>
		You should probably compile the Python binary by either getting a Python 2.x to byte-code compiler or copying the .c file created. This doesn't only boost the security, but the overall speed, especially for large Node systems where there are lots of Nodes spread out across multiple networks- where every byte counts and every second is a must. It also improves the security of the server, because people cannot just access the file and read what's located in the control_node variable and then set up a control node to sabotage your great work.
<p>
	<b>4.7 CONTROL-FILES</b>
	<p>
		Remember that you are not restricted to the CNI alone- you can easily hack the script and then produce another one which does exactly what you want or is better at scaling and programmable stuff. These should be ideally referred to as control-files, which are essentialy files which, upon execution, become a Controller Node.
	<p>
		Doing so not only boosts the creativity of yourself, but the performance of your server itself, as it does exactly what you want and nothing more, nothing less- conditions which dictate and describe the perfect program.
<p>
	<b>4.8 DOWNLOADS</b>
	<p>
		The CNI Interface (Control Node Interface): <a href="http://eugene-eeo.github.com/node/control.py">http://eugene-eeo.github.com/node/control.py</a><br/>
		Node v0.0.1 [Release 2]: <a href="http://eugene-eeo.github.com/node/node.py">http://eugene-eeo.github.com/node/node.py</a><br/>
		Default Worker Node: <a href="http://eugene-eeo.github.com/node/slave.py">http://eugene-eeo.github.com/node/slave.py</a>

<p>
<table width="100%">
	<tr><td width="100%">[<a href="index.html">Back to Index</a>] Authored: Wed Apr 10 22:41:37 2013</td></tr>
	<tr><td width="100%" style="background-color: #3b5998; height:5px"></td></tr>
</table>
</body>
</html>