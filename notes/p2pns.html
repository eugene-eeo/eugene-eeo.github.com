<!doctype html><meta charset=utf-8><style>body{font-family:Georgia,serif;font-size:16px;width:35em;margin:3em auto}code,pre{font-family:Inconsolata,Menlo,Consolas,monospace}li{margin:.5em 0}.has-jax{font:inherit;font-size:90%}h1,h2,h3{font-weight:400}hr{background-color:#000;border:0;height:1px}.footnotes{margin-top:5em;font-size:.75em}table{border-collapse:collapse}th{background-color:#EEE}td,th{border:1px solid #000;padding:.2em .5em}</style><title>p2pns</title><h1>p2pns</h1><p><strong>P2PNS</strong> â€“ an outline of the design of a peer to peer name service suitable for use within small network meshes. P2PNS is completely decentralised and requires no central authority to give out names. A name service can be described as a key-value store, and the problem can be simplified to how to store key-value pairs without allowing arbitrary modifications.<p>A very simple solution to this problem is to require a proof-of-work before modification. All servers will maintain a mapping of names to IP-addresses and high-score counters, for instance:<table><thead><tr><th>domain<th>IP-address<th>high-score<tbody><tr><td>john<td>117.xxx.xxx.xx<td>2<tr><td>don<td>176.xxx.xxx.xx<td>4</table><p>More formally, each entry (IP-address and high-score) can be expressed like so:<p><code>$$ \text{Pair}(\text{address}, \text{high score}) \Rightarrow P(a, c) $$</code><p>A client that wants to change the domain of <code>john</code> to another IP-address will now have to send the change request along with a value, that when hashed will give a higher number of leading zeroes than the current high score (2). A request can be expressed like so:<p><code>$$ \text{Request}(\text{domain}, \text{address}, \text{value}) \Rightarrow R(d, a, v) $$</code><p>The algorithm for updating the mapping, given a request <code>R</code> is the following:<pre><code>def update(mapping, R):
    c = leading_zeroes(hash(R.v))
    if c &gt; mapping[R.d].c:
        mapping[R.d] = P(R.a, c)
</code></pre><p>So far we have only covered <em>registration</em>. A name service needs to have <em>querying</em> capabilities, so we need to define a way for the nodes that run the name service to replicate their state. One very simple approach is to define a merge operation for two mappings:<pre><code>def merge_pair(p1, p2):
    if p1.c &gt; p2.c: return p1
    if p1.c &lt; p2.c: return p2
    return Pair(union(p1.a, p2.a), p1.c)

def merge_mapping(m1, m2):
    merged = {}
    for key in union(m1, m2):
        merged[key] = merge_pair(m1[key], m2[key])
    return merged
</code></pre><p>Servers can simply replicate by communicating their mappings to other nodes, which can then synchronise states by running the merge algorithm. Because it is idempotent, associative, and commutative nodes can merge without fear of any data loss due to ordering differences. One problem arises:<blockquote><p><strong>Two domains may share multiple addresses that have the same high scores.</strong> In this implementation we choose to take the union over the addresses, but an optimisation is to have a periodic GC task that arbitrarily (but deterministically) selects one IP-address from the set, and delete the others to save space.</blockquote><p>A challenge is to generalise the same solution to multi-hashes. A multi hash high score can be represented using a mapping, like the following:<table><thead><tr><th>algorithm<th>high-score<tbody><tr><td>SHA512<td>5<tr><td>SHA256<td>3<tr><td>SHA2<td>2<tr><td>MD5<td>1</table><p>Then we can say that the following is the same as the above mapping, but in more fancy vector form.<p><code>$$ H = \langle 5, 3, 2, 1 \rangle $$</code><p>For the merge algorithm we need to define a partial ordering relationship between any two high-score vectors (of course, from the same basis, i.e. <code>SHA512</code>, <code>SHA256</code>, &hellip; <code>MD5</code> in this case). An intuitive solution is to use a cost function for each of the components. Then we can write, for any high-score vector <code>$ H = \langle H_1, H_2, \ldots H_N \rangle $</code>:<p><code>$$ \text{cost}(H) = \sum_{i=1}^{N}{F_i(H_i)} $$</code><p>Where <code>$ F_i $</code> is the cost function for the <code>$ i $</code>-th component according to some cost function vector/matrix. For instance, if we have the following weights:<p><code>$$ F = \langle 2x^2 + 2x + 10, x^2 + x + 5, 0.5x^2, x \rangle $$</code><p>Then <code>$ \text{cost}(H) $</code> would evaluate to <code>$ F_1(5) + F_2(3) + F_3(2) + F_4(1) = 90 $</code>. Of course the &lsquo;real life&rsquo; cost function vector would be exponential. To merge the two pairs, take the maximum of each component of each high-score vector and then take the address of the maximum high score vector, or in case of ties, the union. For instance:<p><code>$$ \text{merge}( P(a_1, \langle 1, 2 \rangle), P(a_2, \langle 100, 0 \rangle)) = P(a_2, \langle 100, 2 \rangle) $$</code><p>Then the update operation is defined such that an update is only accepted iff at least one of the components is larger than the one in the current high-score vector, and all other components are at least as large as the ones in the current high score vector.<pre><code># returns true if vec1 &gt; vec2
def larger_than(vec1, vec2):
    has_larger = False
    for a, b in zip(vec1, vec2):
        if a &gt; b:
            has_larger = True
        elif a &lt; b:
            return False
    return has_larger
</code></pre><p>So the new, generalised update mechanism is:<pre><code>def update(mapping, R):
    c = highscore_vector_from_values(R.v)
    if larger_than(c, mapping[R.d].c):
        mapping[R.d] = P(R.a, c)
</code></pre><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js></script><script>!function(){function e(e){var t=e.match(a);return t?{TeX:t[1]||t[2],displayMode:!!t[1]}:null}for(var t=document.getElementsByTagName("code"),a=/(?:^\$\$\s*([\s\S]+)\s*\$\$$)|(?:^\$\s*([\s\S]+)\s*\$$)/,s=t.length;s--;){var n=t[s],r=e(n.textContent);r&&(katex.render(r.TeX,n,{displayMode:r.displayMode,throwOnError:!1}),n.classList.add("has-jax"))}}()</script>