<!doctype html><meta charset=utf-8><style>body{font-family:Georgia,serif;font-size:16px;width:35em;margin:3em auto}code,pre{font-family:Inconsolata,Menlo,Consolas,monospace}li{margin:.5em 0}.has-jax{font:inherit;font-size:90%}h1,h2,h3{font-weight:400}hr{background-color:#000;border:0;height:1px}.footnotes{margin-top:5em;font-size:.75em}table{border-collapse:collapse}th{background-color:#EEE}td,th{border:1px solid #000;padding:.2em .5em}</style><title>Bloom Filter Proof</title><h1>Bloom Filter Proof</h1><p>Prove that, for a <code>$ m $</code>-length bit array (Bloom Filter) which already has seen <code>$ n $</code> insertions, and has <code>$ k $</code> hash functions, that:<p><code>$$ k = \frac{m}{n} \ln{2} $$</code><p>is the optimal (minimises the number of false positives) number of hash functions to use. First, the probability that a bit is still 0 (assuming that the prob. of a bit being set is independent) after <code>$ n $</code> insertions:<p><code>$$ (1 - \frac{1}{m})^{kn} \approx e^{-\frac{kn}{m}} $$</code><p>Approximation (for convenience) is from the Macluarin Expansion of <code>$ e^x $</code>:<p><code>$$ \begin{aligned} e^x = 1 + \frac{x}{1!} + \frac{x^2}{2!} + \ldots \\ e^{-\frac{1}{m}} = 1 - \frac{1}{m} + \frac{1}{m^2 \cdot 2!} + \ldots \end{aligned} $$</code><p>Similarly, the probability that a bit is 1 given the conditions above is simply <code>$ 1 - e^{-\frac{kn}{m}} $</code>. Because the algorithm tests membership via testing <code>$ k $</code> bits, the probability for a false positive is:<p><code>$$ E = (1 - e^{-\frac{kn}{m}})^k $$</code><p>Then we need to minimise <code>$ E $</code> wrt <code>$ k $</code> for a fixed <code>$ m $</code> and <code>$ n $</code>.<p><code>$$ \begin{aligned} \ln{E} &amp;= k \ln{(1 - e^{-\frac{kn}{m}})} \\ \frac{dE}{dk} \frac{1}{E} &amp;= \ln{(1 - e^{-\frac{kn}{m}})} + \frac{\frac{kn}{m} e^{-\frac{kn}{m}}}{1 - e^{-\frac{kn}{m}}} \\ \frac{dE}{dk} &amp;= (1 - e^{-\frac{kn}{m}})^k \Big[ \ln{(1 - e^{-\frac{kn}{m}})} + \frac{kn e^{-\frac{kn}{m}}}{m(1 - e^{-\frac{kn}{m}})} \Big] = 0 \\ \end{aligned} $$</code><p>But because <code>$ E $</code> is greater than 0 for all values of <code>$ k $</code>, so we only have to solve for the uglier expression in square brackets. Make the following substitution to remove the fluff:<p><code>$$ \begin{aligned} a &amp;= 1 - e^{-\frac{kn}{m}} \\ \ln{a} - \ln{(1-a)} \cdot \frac{1-a}{a} &amp;= 0 \\ \ln{(1-a)} \cdot \frac{1-a}{a} &amp;= \ln{a} \\ (1 - a) \ln{(1 - a)} &amp;= a \ln{a} \\ 1 - a &amp;= a \\ a &amp;= \frac{1}{2} \end{aligned} $$</code><p>Then just substitute it back to get an answer with the fluff:<p><code>$$ \begin{aligned} e^{-\frac{kn}{m}} &amp;= \frac{1}{2} \\ -\frac{kn}{m} &amp;= - \ln{2} \\ k &amp;= \frac{m}{n} \ln{2} \end{aligned} $$</code></p><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js></script><script>!function(){function e(e){var t=e.match(a);return t?{TeX:t[1]||t[2],displayMode:!!t[1]}:null}for(var t=document.getElementsByTagName("code"),a=/(?:^\$\$\s*([\s\S]+)\s*\$\$$)|(?:^\$\s*([\s\S]+)\s*\$$)/,s=t.length;s--;){var n=t[s],r=e(n.textContent);r&&(katex.render(r.TeX,n,{displayMode:r.displayMode,throwOnError:!1}),n.classList.add("has-jax"))}}()</script>