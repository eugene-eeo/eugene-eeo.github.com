<!doctype html><meta charset=utf-8><style>body{font-family:Georgia,serif;font-size:16px;width:35em;margin:3em auto}code,pre{font-family:Inconsolata,Menlo,Consolas,monospace}li{margin:.5em 0}.has-jax{font:inherit;font-size:90%}h1,h2,h3{font-weight:400}hr{background-color:#000;border:0;height:1px}.footnotes{margin-top:5em;font-size:.75em}table{border-collapse:collapse}th{background-color:#EEE}td,th{border:1px solid #000;padding:.2em .5em}</style><title>triangle meshes</title><h1>triangle meshes</h1><p><strong>Problem:</strong> given a mesh of triangles represented as a collection of vertices, find an efficient way to return the triangle that bounds any given point P.<h2>Solution</h2><p>Assume that the mesh is given in 2D. The solution can be extended to arbitrary dimensions. First allocate a quadtree with dimensions equal to the bounding box of the mesh. The bounding-box for any polygon <code>$ P $</code> is simply a rectangle from the mininimum to maximum of each component:<p><code>$$ \begin{aligned} \text{bounding-box}(P) = &amp;\min(P_x) \leq x \leq \max(P_x), \\ &amp;\min(P_y) \leq y \leq \max(P_y) \end{aligned} $$</code><p>The procedure to determine whether to partition any given region <code>$ R $</code> into 4 sub-regions of equal size is as follows:<pre><code>def to_split(R):
    return R.depth &lt; d and \
           R.triangles_in_region &gt; q
</code></pre><p>The two parameters, <code>$ q $</code> and <code>$ d $</code> determine the size of the quadtree and it&rsquo;s tendency to be partitioned into subregions. A high <code>$ q $</code> will tend to give a quadtree of low depth since splits occur less often, but will impose a slower lookup because at most <code>$ q $</code> polygons need to be tested.<p>A higher <code>$ d $</code> will yield better (in theory) performance as the &lsquo;granularity&rsquo; of the smallest region will be higher, meaning fewer polygons may need to be tested â€“<p><code>$$ \text{granularity}(d) = \frac{\max(P_x) - \min(P_x)}{2^d} $$</code><p>in the x-dimension and similar for the y-dimension, but will give a higher memory cost in the worst case for a very &lsquo;detailed&rsquo; mesh, i.e. one with a lot of very small triangles.<p>To get the bounding triangle of a point, given the quadtree-ified mesh:<pre><code>def bounding_triangle(tree, point):
    node = tree.node_bounding_point(point)
    for triangle in node.triangles:
        if triangle.bounds(point):
            return triangle
    return None
</code></pre><p>A very rough estimate for the running time is <code>$ O(\log n) $</code> where <code>$ n $</code> is the size of the mesh, because quadtree lookups are <code>$ \log n $</code>, but practical implementations depend on the factors <code>$ q $</code> and <code>$ d $</code>.</p><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js></script><script>!function(){function e(e){var t=e.match(a);return t?{TeX:t[1]||t[2],displayMode:!!t[1]}:null}for(var t=document.getElementsByTagName("code"),a=/(?:^\$\$\s*([\s\S]+)\s*\$\$$)|(?:^\$\s*([\s\S]+)\s*\$$)/,s=t.length;s--;){var n=t[s],r=e(n.textContent);r&&(katex.render(r.TeX,n,{displayMode:r.displayMode,throwOnError:!1}),n.classList.add("has-jax"))}}()</script>