<!doctype html><meta charset=utf-8><style>body{font-family:Georgia,serif;font-size:16px;width:35em;margin:3em auto}code,pre{font-family:Inconsolata,Menlo,Consolas,monospace}li{margin:.5em 0}.has-jax{font:inherit;font-size:90%}h1,h2,h3{font-weight:400}hr{background-color:#000;border:0;height:1px}.footnotes{margin-top:5em;font-size:.75em}table{border-collapse:collapse}th{background-color:#EEE}td,th{border:1px solid #000;padding:.2em .5em}</style><title>AVL Trees</title><h1>AVL Trees</h1><ul><li>balanced binary search tree<li><strong>AVL property:</strong> for every internal node <code>$ v $</code>, the heights of the children of <code>$ v $</code> differ by at most 1.</ul><h2>Height</h2><p>Let <code>$ N(h) $</code> be the minimum number of internal nodes of an AVL tree with height <code>$ h $</code>. A tree with height <code>$ h &gt; 2 $</code> is a node joining two subtrees with heights <code>$ h - 1 $</code> and <code>$ h - 2 $</code>, from the AVL property. So we have:<p><code>$$ \begin{aligned} N(h) &amp;= 1 + N(h-1) + N(h-2) \\ N(2) &amp;= 2 \\ N(1) &amp;= 1 \end{aligned} $$</code><p>From <code>$ N(h-1) &gt; N(h-2) $</code>, we get:<p><code>$$ \begin{aligned} N(h) &amp;&gt; 2N(h-2) \\ &amp;&gt; 4N(h-4) \\ &amp;&gt; 8N(h-6) \\ &amp;\ldots \\ &amp;&gt; 2^i N(h-2i) \end{aligned} $$</code><p>Plugging in <code>$ i = h/2 - 1 $</code> so that we get one of the base cases,<p><code>$$ N(h) &gt; 2^{h/2 - 1} N(2) = 2^{h/2} $$</code><p>Then take logarithms:<p><code>$$ \begin{aligned} \log_2 N(h) &amp;&gt; h/2 \\ h &amp;&lt; 2 \log_2 N(h) \\ h &amp;= O(\log n) \end{aligned} $$</code><h3>Tighter Bound</h3><p><strong>Claim:</strong> <code>$ N(h) \geq \varphi^h $</code>, where <code>$ \varphi = (1 + \sqrt{5}) / 2 $</code> (the golden ratio).<p><strong>Intuition:</strong> <code>$ N(h) = 1 + N(h-1) + N(h-2) $</code>. This means it&rsquo;s greater than the Fibonacci series for <code>$ h \geq 2 $</code>, since <code>$ F(h) = F(h-1) + F(h-2) $</code>. We know that the <code>$ h $</code>th Fibonacci number is <code>$ \Theta(\varphi^h) $</code>.<p><strong>Proof:</strong> By induction on <code>$ h $</code>.<p><code>$$ \begin{aligned} h = 0, \,&amp; N(0) = 1 \geq \varphi^0 \\ h = 1, \,&amp; N(1) = 2 \geq \varphi^1 \\ \end{aligned} $$</code><p>Assume it holds for <code>$ h $</code>. Then for <code>$ h + 1 $</code> (note the use of <code>$ \varphi + 1 = \varphi^2 $</code>):<p><code>$$ \begin{aligned} N(h + 1) &amp;= 1 + N(h-1) + N(h) \\ &amp;\geq 1 + \varphi^{h-1} + \varphi^{h} \\ &amp;= 1 + \varphi^{h-1}(1 + \varphi) \\ &amp;= 1 + \varphi^{h+1} \\ &amp;\gt \varphi^{h+1} \end{aligned} $$</code><p>Again cleaning up and using the claim:<p><code>$$ \begin{aligned} n &amp;\geq N(h) \geq \varphi^{h} \\ h &amp;\leq \log_\varphi{n} \\ &amp;= \frac{\log_2{n}}{\log_2{\varphi}} = 1.44 \log{n} \end{aligned} $$</code><h2>Restructuring</h2><p>Let <code>$ (a, b, c) $</code> be an in-order listing of <code>$ x, y, z $</code>. Then we need to perform rotations to make <code>$ b $</code> the topmost node of the three. We need to consider two cases:<ul><li><p><code>$ b $</code> is a right child node of <code>$ a $</code> and <code>$ c $</code> is a right child node of <code>$ b $</code> (single rotation). Then we need to restructure <code>$ b $</code> so that <code>$ a $</code> is its left child and <code>$ c $</code> its right.<li><p><code>$ a $</code> has a right child <code>$ c $</code> and <code>$ c $</code> has a right child <code>$ b $</code> (double rotation). Again we need to restructure so that we have <code>$ b $</code> as the parent of <code>$ a, c $</code>.</ul><p>The restructuring operations are symmetric for the case where <code>$ b $</code> is the left child of <code>$ c $</code>. A simple analysis of the running time for restructuring follows.<p><strong>Claim:</strong> Inserting and rebalancing the tree (so that the AVL invariant holds) can be done in <code>$ O(\log n) $</code> time.<p><strong>Proof:</strong> A simple strategy to rebalance is as follows:<ol><li>Let <code>$ w $</code> be a node that is inserted (therefore, a leaf node).<li>Let <code>$ h $</code> denote the parent of <code>$ w $</code>.<li>Restructure <code>$ h $</code> by single or double rotation as necessary.<li>Then rebalance the parent of <code>$ h $</code>, and so on until we reach the root of the tree.</ol><p>Inserting into a balanced tree is always <code>$ O(\log n) $</code>. Since single and double rotation is a <code>$ O(1) $</code> operation, and the height of the tree is at most, <code>$ O(\log n) $</code>, then at worse we need to restructure <code>$ O(\log n) $</code> times.</p><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js></script><script>!function(){function e(e){var t=e.match(a);return t?{TeX:t[1]||t[2],displayMode:!!t[1]}:null}for(var t=document.getElementsByTagName("code"),a=/(?:^\$\$\s*([\s\S]+)\s*\$\$$)|(?:^\$\s*([\s\S]+)\s*\$$)/,s=t.length;s--;){var n=t[s],r=e(n.textContent);r&&(katex.render(r.TeX,n,{displayMode:r.displayMode,throwOnError:!1}),n.classList.add("has-jax"))}}()</script>