<!doctype html><meta charset=utf-8><style>body{font-family:Georgia,serif;font-size:16px;width:35em;margin:3em auto}code,pre{font-family:Inconsolata,Menlo,Consolas,monospace}li{margin:.5em 0}.has-jax{font:inherit;font-size:90%}h1,h2,h3{font-weight:400}hr{background-color:#000;border:0;height:1px}.footnotes{margin-top:5em;font-size:.75em}table{border-collapse:collapse}th{background-color:#EEE}td,th{border:1px solid #000;padding:.2em .5em}</style><title>Tree Traversal Space Requirements</title><h1>Tree Traversal Space Requirements</h1><p>For a tree with <code>$ n $</code> total nodes, where each node has <code>$ \mu $</code> average number of children, and <code>$ D $</code> is the depth/height of the tree, we can write (the summation is from 0 because of the root node):<p><code>$$ n \approx \sum_{d=0}^{D}{\mu^d} $$</code><p>Given a &ldquo;perfect&rdquo; tree where each node has <code>$ \mu $</code> children, the maximum number of nodes we need to store in a FIFO queue for breadth first traversal is the number of nodes in the last depth, <code>$ \mu^D $</code>. Rearranging to find <code>$ \mu^D $</code> in terms of <code>$ n $</code>:<p><code>$$ n = \sum_{d=0}^{D}{\mu^d} = \frac{\mu^{D+1} - 1}{\mu - 1} $$</code><p><code>$$ \mu^D = \frac{n (\mu - 1) + 1}{\mu} $$</code><p>I think a good approximation that unfortunately makes breadth-first algorithms look quite bad is then:<p><code>$$ O(n(1 - \frac{1}{\mu})) \approx O(n) $$</code><p>For the same conditions, a depth first traversal is much cheaper. We need only to store <code>$ D $</code> nodes in a stack (just for traversing). So the space required is given by:<p><code>$$ \begin{aligned} D &amp;= \log_{\mu}{\frac{n (\mu - 1) + 1}{\mu}} \\ &amp;= \log_{\mu}{(n (\mu - 1) + 1)} - 1 \end{aligned} $$</code><p>And a good approximation is then:<p><code>$$ O(\log{(\mu n)}) \approx O(\log{n}) $$</code></p><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js></script><script>!function(){function e(e){var t=e.match(a);return t?{TeX:t[1]||t[2],displayMode:!!t[1]}:null}for(var t=document.getElementsByTagName("code"),a=/(?:^\$\$\s*([\s\S]+)\s*\$\$$)|(?:^\$\s*([\s\S]+)\s*\$$)/,s=t.length;s--;){var n=t[s],r=e(n.textContent);r&&(katex.render(r.TeX,n,{displayMode:r.displayMode,throwOnError:!1}),n.classList.add("has-jax"))}}()</script>