<!doctype html><meta charset=utf-8><style>body{font-family:Georgia,serif;font-size:16px;width:35em;margin:3em auto}code,pre{font-family:Inconsolata,Menlo,Consolas,monospace}li{margin:.5em 0}.has-jax{font:inherit;font-size:90%}h1,h2,h3{font-weight:400}hr{background-color:#000;border:0;height:1px}.footnotes{margin-top:5em;font-size:.75em}table{border-collapse:collapse}th{background-color:#EEE}td,th{border:1px solid #000;padding:.2em .5em}</style><title>Heapify Bounds</title><h1>Heapify Bounds</h1><p><strong>Claim:</strong> in the worst case, Heapify has time complexity <code>$ T(n) \leq T(\frac{2n}{3}) + \Theta(1) $</code> when called on a heap with <code>$ n $</code> nodes.<pre><code>function Heapify(H, v, n)
    i &lt;- v
    if 2v &lt;= n and H[2v] &gt; H[v]:
        i &lt;- 2v
    if 2v+1 &lt;= n and H[2v+1] &gt; H[i]:
        i &lt;- 2v + 1
    if i â‰  v:
       swap H[i], H[v]
       Heapify(H, i, n)
</code></pre><p><strong>Proof:</strong> The hard part is pulling out the fraction <code>$ {2 \over 3} $</code>. The <code>$ \Theta(1) $</code> is trivial. Consider an &lsquo;unbalanced&rsquo; heap with the left subtree larger than the right subtree (this can be the only unbalanced case since heaps fill from left to right). In the worst case, the left subtree has a full bottom layer while the right subtree has no bottom nodes.<p><center><img src=http://scienceblogs.com/goodmath/wp-content/blogs.dir/476/files/2012/04/i-1f1c6859be504203721c6c61b4ade2a2-heap-example.png></center><p>Say we start at some node at height <code>$ h $</code>. Let <code>$ |L| $</code> denote the number of nodes in the left subtree and <code>$ |R| $</code> the number of nodes in the right subtree. In the worst case we have:<p><code>$$ \begin{aligned} |L| &amp;= \sum_{i=0}^{h-1}{2^i} = 2^h-1 \\ |R| &amp;= \sum_{i=0}^{h-2}{2^i} = 2^{h-1} - 1 \\ \end{aligned} $$</code><p>The total number of nodes of the subtree rooted in the current node is given by <code>$ |N| = 1 + |L| + |R| $</code> (add an extra 1 for the current node since that is not included in the left or right subtrees). So in the worse case, we recurse into the left subtree and end up with a subtree of <code>$ \frac{|L|}{|N|} $</code> as many nodes as we have previously. Bounding this fraction:<p><code>$$ \begin{aligned} {|L| \over |N|} &amp;\leq \lim_{n \to \infty}{\frac{|L|}{|N|}} \\ &amp;= \lim_{n \to \infty}{\frac{|L|}{1 + |L| + |R|}} \\ &amp;= \lim_{n \to \infty}{\frac{2^h-1}{1 + 2^h - 1 + 2^{h-1} - 1}} \\ &amp;= \lim_{n \to \infty}{\frac{2\cdot2^{h-1}-1}{2\cdot2^{h-1} + 2^{h-1} - 1}} \\ &amp;= \lim_{n \to \infty}{\frac{2\cdot2^{h-1}-1}{3\cdot2^{h-1} - 1}} \\ &amp;= \frac{2}{3} \end{aligned} $$</code><p>As required. <em>Note:</em> Even though we can recurse into a subtree that has <code>$ \frac{2}{3} $</code> as many nodes as before, the algorithm is still logarithmic. Furthermore this fraction only holds for the <em>first</em> recursion, since on the next recursion we will get half as many nodes on either side.</p><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js></script><script>!function(){function e(e){var t=e.match(a);return t?{TeX:t[1]||t[2],displayMode:!!t[1]}:null}for(var t=document.getElementsByTagName("code"),a=/(?:^\$\$\s*([\s\S]+)\s*\$\$$)|(?:^\$\s*([\s\S]+)\s*\$$)/,s=t.length;s--;){var n=t[s],r=e(n.textContent);r&&(katex.render(r.TeX,n,{displayMode:r.displayMode,throwOnError:!1}),n.classList.add("has-jax"))}}()</script>