<!doctype html><meta charset=utf-8><style>body{font-family:Georgia,serif;font-size:16px;width:35em;margin:3em auto}code,pre{font-family:Inconsolata,Menlo,Consolas,monospace}li{margin:.5em 0}.has-jax{font:inherit;font-size:90%}h1,h2,h3{font-weight:400}hr{background-color:#000;border:0;height:1px}.footnotes{margin-top:5em;font-size:.75em}table{border-collapse:collapse}th{background-color:#EEE}td,th{border:1px solid #000;padding:.2em .5em}</style><title>Eggs and Floors Problem</title><h1>Eggs and Floors Problem</h1><p>A generalisation of the eggs and floors problem is the following: given <code>$ e $</code> eggs and <code>$ f $</code> floors, find the minimum number of egg drops in the worse case to determine the floor that the egg breaks. We can assume that the egg does not break or get damaged (and as such can be re-used indefinitely) as long as the floor it is dropped on <code>$ \lt f_{\text{breaking}} $</code>.<p>Let <code>$ W(e,f) $</code> be the minimum number of egg drops we need to perform, in the worse case given some <code>$ e $</code> and some <code>$ f $</code>. It follows simply that:<p><code>$$ W(1, f) = f $$</code><p>Because if we only have one egg, there is no alternative but to drop it from every floor, starting from the bottom. Combining the knowledge above and eliminating some obvious cases, we have:<p><code>$$ W(e, f) = \begin{cases} 0 &amp; \text{if}\, f = 0,\\ 1 &amp; \text{if}\, f = 1,\\ f &amp; \text{if}\, e = 1,\\ F(e, f) &amp; \text{otherwise.} \end{cases} $$</code><p>To find <code>$ F(e, f) $</code>, consider a simple strategy to test for the egg-breaking floor, given two eggs. (It can be generalised to more eggs, but the idea is the same):<ol><li>Pick some floor <code>$ x $</code>. Drop an egg from <code>$ x $</code>.<li>If the egg breaks then <code>$ f_{\text{breaking}} \leq x $</code>; we need to do a linear search on the floors below <code>$ x $</code> with one egg.<li>Else, we can repeat the two-egg procedure but for the floors above <code>$ x $</code>.</ol><p>Naturally we would want to find the <code>$ x $</code> that minimises the number of drops we need to do. Intuitively this should be the &lsquo;middle&rsquo; floor as it eliminates more than half of the floors. If we have more eggs, we can eliminate more floors. A formalised version of the above strategy for any <code>$ x $</code>:<p><code>$$ F(e, f) = 1 + \min_{x \in [1,f]} \{ {\max(W(e-1, x-1), W(e, f-x))} \} $$</code><p>What <code>$ F(e,f) $</code> does is that it finds the optimal value for the floor <code>$ x $</code> such that the total number of egg drops after the initial drop is minimised:<ul><li><code>$ W(e-1, x) $</code> – the egg broke, so we need to search the floors below <code>$ x $</code>.<li><code>$ W(e, f-x) $</code> – search the floors above <code>$ x $</code> with the same number of eggs. Notice in both cases the floor <code>$ x $</code> is <em>not</em> searched again.</ul><p>The Python program to compute the minimum number of eggs to drop in the worse case, to determine the floor which is high enough to break the eggs:<pre><code>def W(e, f):
    if f == 0: return 0
    if f == 1: return 1
    if e == 1: return f
    return 1 + min(
        max(W(e-1, x), W(e, f-x)) for x in range(1, f+1)
    )
</code></pre><p><img src=https://i.imgur.com/hSvBJwA.png width=100%></p><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js></script><script>!function(){function e(e){var t=e.match(a);return t?{TeX:t[1]||t[2],displayMode:!!t[1]}:null}for(var t=document.getElementsByTagName("code"),a=/(?:^\$\$\s*([\s\S]+)\s*\$\$$)|(?:^\$\s*([\s\S]+)\s*\$$)/,s=t.length;s--;){var n=t[s],r=e(n.textContent);r&&(katex.render(r.TeX,n,{displayMode:r.displayMode,throwOnError:!1}),n.classList.add("has-jax"))}}()</script>