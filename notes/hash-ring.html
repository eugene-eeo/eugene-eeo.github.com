<!doctype html><meta charset=utf-8><style>body{font-family:Georgia,serif;font-size:16px;width:35em;margin:3em auto}code,pre{font-family:Inconsolata,Menlo,Consolas,monospace}li{margin:.5em 0}.has-jax{font:inherit;font-size:90%}h1,h2,h3{font-weight:400}hr{background-color:#000;border:0;height:1px}.footnotes{margin-top:5em;font-size:.75em}table{border-collapse:collapse}th{background-color:#EEE}td,th{border:1px solid #000;padding:.2em .5em}</style><title>Consistent Hash Rings</title><h1>Consistent Hash Rings</h1><p>A hash ring is a ring from <code>$ [0, 1) $</code>. Given any hash function that has the range <code>$ [0, R) $</code> we can define a new, ring-ified function <code>$ h(x) $</code>:<p><code>$$ h(x) = \frac{\text{hash}(x)}{R} $$</code><p>For each <code>$ m_i $</code> in a set of machine IDs <code>$ M = \{m_1, m_2, \ldots, m_n\} $</code>, store <code>$ h(m_i) $</code> on the ring. To store any value <code>$ v $</code> in the cluster, store it in the machine corresponding to the highest value of <code>$ m_j $</code> such that <code>$ m_j \leq h(v) $</code> (clockwise). Then to &lsquo;scale up&rsquo; the cluster, just hash and store the ID of the new machine on the ring. Problem:<blockquote><p>If <code>$ h(m_a) $</code> and <code>$ h(m_b) $</code> are very similar in value then one machine will end up getting most of the keys, while the other only a small subset. This is not desirable since it increases the tendency for a single point of failure.</blockquote><p>Solution: a <em>replica count</em> parameter (not related to data replication) <code>$ r $</code>. For each machine ID <code>$ m_i $</code>, hash <code>$ (m_i, 1), (m_i, 2), \ldots (m_i, r) $</code> and store it on the ring. To store <code>$ v $</code> the same process is repeated, but we get more even distribution of values.</p><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js></script><script>!function(){function e(e){var t=e.match(a);return t?{TeX:t[1]||t[2],displayMode:!!t[1]}:null}for(var t=document.getElementsByTagName("code"),a=/(?:^\$\$\s*([\s\S]+)\s*\$\$$)|(?:^\$\s*([\s\S]+)\s*\$$)/,s=t.length;s--;){var n=t[s],r=e(n.textContent);r&&(katex.render(r.TeX,n,{displayMode:r.displayMode,throwOnError:!1}),n.classList.add("has-jax"))}}()</script>