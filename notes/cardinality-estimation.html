<!doctype html><meta charset=utf-8><style>body{font-family:Georgia,serif;font-size:16px;width:35em;margin:3em auto}code,pre{font-family:Inconsolata,Menlo,Consolas,monospace}li{margin:.5em 0}.has-jax{font:inherit;font-size:90%}h1,h2,h3{font-weight:400}hr{background-color:#000;border:0;height:1px}.footnotes{margin-top:5em;font-size:.75em}table{border-collapse:collapse}th{background-color:#EEE}td,th{border:1px solid #000;padding:.2em .5em}</style><title>Cardinality Estimation</title><h1>Cardinality Estimation</h1><p><strong>Cardinality â€“ how many unique items in a sequence.</strong> Normal approach of putting (and remembering) items inside the set requires linear space, not suitable for &ldquo;big data&rdquo;.<p>A good estimation is to use the fact that good hash functions produce bits which value are (almost) statistically independent from one another. For instance we can put the hashes into &lsquo;buckets&rsquo;, depending on the first two bits. All buckets start off initially with value of 0.<table><thead><tr><th align=center><code>00</code><th align=center><code>01</code><th align=center><code>10</code><th align=center><code>11</code><tbody><tr><td align=center>0<td align=center>0<td align=center>0<td align=center>0</table><p>Each bucket will store the higest number of trailing zeroes. For instance if we see the value <code>001001100</code>, we&rsquo;ll put it inside bucket <code>00</code> and then update the counter to be 2. However if we see the value <code>001001110</code> we will not update the counter because 1 is less than 2.<p>Then take a hash function <code>$ h $</code> and apply it to each of the values in the sequence, <code>$ v_1, v_2, v_3, \ldots $</code> and then update the corresponding buckets. e.g. given the following hashes:<ul><li><code>010010110</code><li><code>011010010</code><li><code>110011010</code><li><code>100011011</code></ul><p>We&rsquo;ll end up with the table:<table><thead><tr><th align=center><code>00</code><th align=center><code>01</code><th align=center><code>10</code><th align=center><code>11</code><tbody><tr><td align=center>0<td align=center>1<td align=center>0<td align=center>1</table><p>The probability of getting <code>$ n $</code> zeroes at the end is <code>$ 2^{-n} $</code>, assuming we have a good enough hash function. Note a very simple concept: if something happens 1/8ths of the time we expect that if we repeat the action 8 times at least 1 will be successful.<p>In the same way a (bad) estimate for the size of the set, given a counter of values <code>$ c_1, c_2, c_3, \ldots $</code> will be given by:<p><code>$$ 2^{c_1} + 2^{c_2} + \ldots = \sum_{i=1}^{n}{2^{c_i}} $$</code><p>If we evaluate it for our table it gives 6. Which is wrong but the estimate gets better as we increase the number of buckets (hence increase the length of the prefix) and put more data inside it.</p><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js></script><script>!function(){function e(e){var t=e.match(a);return t?{TeX:t[1]||t[2],displayMode:!!t[1]}:null}for(var t=document.getElementsByTagName("code"),a=/(?:^\$\$\s*([\s\S]+)\s*\$\$$)|(?:^\$\s*([\s\S]+)\s*\$$)/,s=t.length;s--;){var n=t[s],r=e(n.textContent);r&&(katex.render(r.TeX,n,{displayMode:r.displayMode,throwOnError:!1}),n.classList.add("has-jax"))}}()</script>