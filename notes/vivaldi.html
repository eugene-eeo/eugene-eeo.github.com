<!doctype html><meta charset=utf-8><style>body{font-family:Georgia,serif;font-size:16px;width:35em;margin:3em auto}code,pre{font-family:Inconsolata,Menlo,Consolas,monospace}li{margin:.5em 0}.has-jax{font:inherit;font-size:90%}h1,h2,h3{font-weight:400}hr{background-color:#000;border:0;height:1px}.footnotes{margin-top:5em;font-size:.75em}table{border-collapse:collapse}th{background-color:#EEE}td,th{border:1px solid #000;padding:.2em .5em}</style><title>Vivaldi Coordinates</title><h1>Vivaldi Coordinates</h1><p><strong>Aim:</strong> to provide a simple internet coordinate system to help predict the RTT between nodes without direct measurement/communication. Vivaldi attempts to reduce the global squared-error function of the coordinates:<p><code>$$ E = \sum_i{\sum_j{(L_{ij} - || x_i - x_j ||)^2}}, $$</code><p>where <code>$ || x_i - x_j || $</code> is the distance between coordinates of node <code>$ i $</code> and <code>$ j $</code> in some coordinate space (Vivaldi is using a 2D + height vector). Claim: using a system of physical springs, the force between nodes <code>$ i $</code> and <code>$ j $</code> is given by:<p><code>$$ F_{ij} = (L_{ij} - || x_i - x_j ||) \times u(x_i - x_j), $$</code><p>where the <code>$ L_{ij} - \ldots $</code> term is the displacement of the spring from rest, and <code>$ u(x_i - x_j) $</code> is a unit vector in the direction of <code>$ x_i - x_j $</code>. To do global (where coordinates and exact latencies to all other nodes are known) error/force minimisation for some node <code>$ i $</code> we need to shift the position of the node by a small amount, <code>$ \delta $</code> in the direction of the resultant force:<p><code>$$ x_i = x_i + \delta \sum_{j \neq i}{F_{ij}} $$</code><p>A simple way to do this without global knowledge is to simulate the spring system locally on the node. To do this we only need the measured <code>$ rtt $</code> (time for sending the signal + receiving an ack) between node <code>$ j $</code> and it&rsquo;s coordinates, <code>$ x_j $</code>.<p><code>$$ x_i = x_i + \delta (rtt - || x_i - x_j ||) \times u(x_i - x_j) $$</code><p>However such a system would allow for too much fluctuation in the coordinates of the &lsquo;older, wiser&rsquo; nodes once many new nodes enter the system. So an adaptive <code>$ \delta $</code> is needed:<p><code>$$ \delta \propto \frac{\text{local error}}{\text{local error} + \text{remote error}} $$</code><p>and the local error of a node, <code>$ e_i $</code> needs to be tracked. The new algorithm, given some measurement <code>$ rtt $</code>, <code>$ x_j $</code> and some error estimate <code>$ e_j $</code> of a remote node is again:<p><code>$$ \begin{aligned} w &amp;= \frac{e_i}{e_i + e_j} \\ e_s &amp;= \frac{| ||x_i - x_j|| - rtt |}{rtt} \\ e_i &amp;= e_i + w \times c_e(e_s - e_i) \\ \delta &amp;= c_c \times w \\ x_i &amp;= x_i + \delta (rtt - ||x_i - x_j||) \times u(x_i - x_j) \end{aligned} $$</code><p>Where <code>$ c_e $</code> and <code>$ c_c $</code> are constants. Vivaldi is defined for any coordinate system that supports the vector subtraction, scalar distance, and scalar multiplication operations. The height vector model where a 2D coordinate <code>$ x $</code> comes with a scalar height <code>$ x_h $</code> is favoured:<p><code>$$ \begin{aligned} [x, x_h] - [y, y_h] &amp;= [(x - y), x_h + y_h] \\ || [x, x_h] || &amp;= || x || + x_h \\ k \times [x, x_h] &amp;= [kx, kx_h] \end{aligned} $$</code></p><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js></script><script>!function(){function e(e){var t=e.match(a);return t?{TeX:t[1]||t[2],displayMode:!!t[1]}:null}for(var t=document.getElementsByTagName("code"),a=/(?:^\$\$\s*([\s\S]+)\s*\$\$$)|(?:^\$\s*([\s\S]+)\s*\$$)/,s=t.length;s--;){var n=t[s],r=e(n.textContent);r&&(katex.render(r.TeX,n,{displayMode:r.displayMode,throwOnError:!1}),n.classList.add("has-jax"))}}()</script>